package bayou.http;

import _bayou._tmp.*;
import bayou.async.Async;
import bayou.bytes.ByteSource;
import bayou.bytes.RangedByteSource;
import bayou.gzip.GzipByteSource;
import bayou.gzip.GzipHttpEntity;
import bayou.mime.ContentType;
import bayou.mime.HeaderMap;

import java.nio.ByteBuffer;
import java.time.Instant;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.Map;

import static bayou.http.HttpStatus.*;
import static bayou.mime.Headers.*;

class ImplRespMod
{

    // simple mod for error response generated by server;
    // request can be null, or incomplete, or bad in other ways.
    // should not throw - no user code is involved
    static ImplConnResp modErr(ImplConn hConn, ImplHttpRequest request, HttpResponseImpl response)
    {
        // we can freely modify the response
        HttpStatus status = response.status();

        HeaderMap headers = response.headers;

        // Cache-Control for error responses? probably not needed.

        // error response won't be 1xx/204/304; must have an entity
        assert status.code>=200 && status.code!=204 && status.code!=304;
        HttpEntity entity = response.entity();
        if(entity==null)  // probably never null. over-caution
            response.entity = entity = new HttpHelper.SimpleTextEntity(status.toString());


        // no mod: gzip, conditional, range



        ContentType contentType = entity.contentType();
        if(contentType!=null)  // probably never null. over-caution
            headers.put(Content_Type, contentType.toString());  // contentType is sane
        //legal to have no Content-Type. it's up to client to guess

        // no other entity headers from error responses
        assert entity.contentEncoding()==null;
        assert entity.etag()==null;
        assert entity.lastModified()==null;
        assert entity.expires()==null;

        // 0 or 1. could be even -1 if request parse error.
        int httpMinorVersion= request==null? -1 : request.httpMinorVersion;


        int bodyType;  // [0] empty  [1] entity.getBody()  [2] chunk(entity.getBody())
        long bodyLength;
        Long L = entity.contentLength();
        if(L==null) // probably never null; error responses have short plain text of known size.
        {
            bodyLength = -1;
            if(httpMinorVersion>=1)  // version could be 0 or even -1
            {
                headers.put(Transfer_Encoding, "chunked");
                bodyType = 2;
            }
            else
            {
                // write response without Content-Length/Transfer-Encoding, then close the connection.
                bodyType = 1;
            }
        }
        else
        {
            bodyType = 1;
            bodyLength = L.longValue();
            assert bodyLength >= 0;
            headers.put(Content_Length, Long.toString(bodyLength));
        }

        // note: request can be null, or incomplete, or bad in other ways.
        boolean isHEAD = request!=null && request.method!=null && request.method.equals("HEAD");
        // if we don't even get the method token, consider it a non-HEAD req,
        // we'll send whole response, client bares the consequence if that's inappropriate
        if(isHEAD)
        {
            bodyLength = 0; // actual body length. we've set would-be Content-Length/Transport-Encoding headers
            bodyType = 0;   // avoided calling entity.getBody()
        }

        // input is likely corrupt, conn cannot be reused. even if not, we should punish client.
        boolean isLast=true;
        headers.put(Connection, "close");   // there was no Connection

        headers.put(Date, _HttpDate.getCurrStr());  // there was no Date
        headers.put(Server, "Bayou");

        // done
        ByteSource body = body(hConn.conf, entity, bodyType);
        return new ImplConnResp(hConn, response, isLast, httpMinorVersion, body, bodyLength);
    }

    // resolve body. delayed till the last step to avoid error handling
    // (if we called entity.body() earlier, and then an error occurs, we need to close the body)
    static ByteSource body(HttpServerConf conf, HttpEntity entity, int bodyType)
    {
        if(bodyType==0)
            return theEmptyBody;

        ByteSource body = entity.body(); // user code
        if(bodyType==1)
            return body;

        if(bodyType==2)
            return new ImplRespChunkedSource(conf.outboundBufferSize, body);

        if(bodyType==3)
            return new ImplRespChunkedSource(conf.outboundBufferSize, new GzipByteSource(body, 1));

        throw new AssertionError();
    }

    static final ByteSource theEmptyBody = new ByteSource() // stateless, shared. might be needed a lot for 304
    {
        @Override public Async<ByteBuffer> read() { return _Util.EOF; }
        @Override public Async<Void> close() {  return Async.VOID; }
    };


    // #############################################################################################################



    // may throw from user code from user object `appResponse`. treat it as unexpected.
    static ImplConnResp modApp(ImplConn hConn, ImplHttpRequest request, HttpResponse appResponse,
                               ArrayList<Cookie> jarCookies)
    {
        // here we depend on original request headers, which we know app cannot temper with.

        HttpStatus statusL = appResponse.status(); // may change later (200 to 304/412/206)
        int statusCodeL = statusL.code;
        if(statusCodeL<200)  // 1xx not supported
            throw new AssertionError("non-final status code ["+statusCodeL+"] not allowed in HttpResponse");

        HttpEntity entityL = appResponse.entity(); // may change later

        if(statusCodeL==204 || statusCodeL==304) // must have no entity
        {
            if(entityL!=null) // be strict
                throw new AssertionError("response must not have entity for status "+statusCodeL);
        }
        else // must have an entity
        {
            if(entityL==null) // be strict
                throw new AssertionError("response must have an entity for status "+statusCodeL);
        }


        // make a copy of response; don't touch the original (e.g. it may be a shared stock response)
        HttpResponseImpl resp = new HttpResponseImpl();
        resp.status = statusL;
        resp.entity = entityL;

        resp.cookies = jarCookies;
        resp.cookies.addAll(appResponse.cookies());

        // copy headers.
        resp.headers = new HeaderMap();
        HeaderMap headers = resp.headers;
        for(Map.Entry<String,String> entry : appResponse.headers().entrySet())
        {
            String name = entry.getKey();
            String value = entry.getValue();
            // we don't trust name/value. check them.
            _HttpUtil.checkHeader(name, value);
            headers.put(name, value);
        }

        HttpServerConf conf = hConn.conf;
        boolean isGET  = request.method.equals("GET");
        boolean isHEAD = request.method.equals("HEAD");
        boolean GET_HEAD = isGET || isHEAD;
        HeaderMap requestHeaders = request.headers;


        // resp.status may change later (200 to 304/412/206)
        // resp.entity may change later (gzip, null, ranged)
        // be careful of the local variables for status/entity

        int acceptGzip = 0; // [0] no [1] TE: gzip [2] Accept-Encoding: gzip
        if(+1==acceptEncoding(requestHeaders.get(TE), "gzip"))
            acceptGzip = 1;
        else if (+1==acceptEncoding(requestHeaders.get(Accept_Encoding), "gzip"))
            acceptGzip = 2;

        if(acceptGzip!=1 && conf.autoGzip)  // for any request method and response status (with an entity)
            modGzip(acceptGzip, resp, conf); // may change entity to gzip-ed
        // compression is lazy. it's ok if later the gzip-ed entity is dropped
        // gzip-ed entity has unknown body length, so later range mod won't work.

        if(conf.autoConditional && GET_HEAD && resp.status.code==200)
            modConditional(resp, requestHeaders);  // may change 200 to 304 or 412. entity=null if 304.

        if(conf.autoRange && GET_HEAD && resp.status.code==200)
            modRange(resp, requestHeaders);        // may change 200 to 206. entity ranged if 206

        // note: range is done after conditional. this is not clear from the messy language of the spec.

        // we may have modified app response status and entity, yet we keep the original headers.
        // not sure if that will cause inconsistency. if so, app may have to disable auto mod.

        // no more changes to status/entity
        statusL = resp.status;
        statusCodeL = statusL.code;
        entityL = resp.entity;

        // above: transform one HttpResponse to another
        // ===
        // below: convert HttpResponse to http message head&body


        if(entityL!=null)
            copyEntityHeaders(entityL, headers);  // no Content-Length

        if(conf.autoCacheControl && GET_HEAD)
            modCacheControl(entityL, headers);

        // body

        // app should not set these two headers, or we'll remove them
        String hContentLength = null;
        String hTransferEncoding = null;

        // we delay calling entity.body() till last moment. for now, just determine type of body
        int bodyType;  // [0] empty  [1] entity.body  [2] chunk(entity.body)  [3] chunk(gzip(entity.body))
        long bodyLength;  // -1 if unknown; otherwise >=0
        if(entityL==null) // 204 or 304
        {
            bodyLength = 0;
            bodyType = 0;
            // do NOT set Content-Length in 204/304
        }
        else
        {
            Long BL = entityL.contentLength();
            if(acceptGzip==1 && conf.autoGzip && shouldGzip(entityL, conf))
            {
                bodyLength = -1;
                hTransferEncoding = "gzip,chunked";
                bodyType = 3;
            }
            else if(BL!=null)
            {
                bodyLength = BL.longValue();  // can be 0
                if(bodyLength<0)
                    throw new AssertionError("entity.getBodyLength() < 0");

                hContentLength = Long.toString(bodyLength);
                bodyType = 1;
            }
            else
            {
                bodyLength=-1;
                if(request.httpMinorVersion>=1)
                {
                    hTransferEncoding = "chunked";
                    bodyType = 2;
                }
                else // HTTP/1.0 client. no chunked, no Content-Length. body ends when connection closes
                {
                    bodyType = 1;
                }
            }

            if(isHEAD)
            {
                bodyLength = 0; // actual body length. we've set would-be Content-Length/Transport-Encoding headers
                bodyType = 0;
                // entity.body() will not be called. but that could be a problem, e.g. body is already constructed
                // and it needs to be closed, like body is source of a BytePipe, and app is writing to the sink.
                // for now, app has to make sure body() is lazy; creates pipe only when body() is called.
            }
        }

        if(hContentLength!=null)
            headers.put(Content_Length, hContentLength);
        else
            headers.remove(Content_Length);  // in case app set it

        if(hTransferEncoding!=null)
            headers.put(Transfer_Encoding, hTransferEncoding);
        else
            headers.remove(Transfer_Encoding);   // in case app set it



        // Connection header. depends on body length
        String respConnection = headers.get(Connection);
        String reqConnection = requestHeaders.get(Connection);

        boolean isLast = isLastResponse(
                request.httpMinorVersion, bodyLength, request.state100,
                respConnection, reqConnection, statusCodeL);

        respConnection = modConnectionHeader(respConnection, isLast);
        // respConnection was checked; still valid after modConnectionHeader()
        headers.put(Connection, respConnection);


        // other headers
        if(!headers.containsKey(Date))
            headers.put(Date, _HttpDate.getCurrStr());

        String hServer = headers.get(Server);
        if(hServer==null || hServer.isEmpty())
            hServer = "Bayou";
        else
            hServer = "Bayou " + hServer;  // hServer was checked, is still valid
        headers.put(Server, hServer);


        ByteSource body = body(conf, entityL, bodyType);
        return new ImplConnResp(hConn, resp, isLast, request.httpMinorVersion, body, bodyLength); // no throw
    }

    static boolean isLastResponse(int httpMinorVersion, long bodyLength, int state100,
                                  String respConnection, String reqConnection, int statusCode)
    {
        // app can instruct Connection:close in response headers
        if(containsToken(respConnection, "close"))
            return true;

        // close if request explicitly says Connection: close.
        if(containsToken(reqConnection, "close"))
            return true;

        if(httpMinorVersion==0) // HTTP/1.0
        {
            // close if request does not explicitly say Connection: keep-alive
            if( ! containsToken(reqConnection, "keep-alive") )
                return true;

            if(bodyLength==-1)  // body of unknown length. no Content-Length
                return true;    // use transport EOF to mark end-of-body

            if(statusCode==204 || statusCode==304)
                return true;
            // no body. no Content-Length header.
            // not sure how an HTTP/1.0 client, even with keep-alive capacity, would react.
            // would it try to read a body till tcp close? to be safe, close the connection.

            // otherwise, safe to keep the connection alive for the HTTP/1.0 client.
            // 1. either there is a Content-Length header, client will read fixed number of bytes.
            // 2. or request is HEAD - we expect client to understand that there won't be a body.
        }

        if(state100==1)   // "Expect: 100-continue", but response is generated without reading request body.
            return true;  // won't read request body. won't read more requests. this is the last response.

        // no reason to close. keep-alive for next request. this is most likely.
        return false;
    }

    // tokenList is a list of simple tokens separated by comma
    // impl is fast there's no comma (single token)
    static boolean containsToken(String tokenList, String token)
    {
        if(tokenList==null)
            return false;

        int i=0;
        while(i<tokenList.length())
        {
            int j = tokenList.indexOf(',', i);
            if(j==-1)
                j = tokenList.length();
            String t = tokenList.substring(i,j).trim();
            if(_StrUtil.equalIgnoreCase(t, token))
                return true;
            i = j+1;
        }
        return false;
    }

    // set "close/keep-alive" in the resp Connection header.
    static String modConnectionHeader(String header, boolean close)
    {
        if(header==null) // most likely response has no Connection header
            return close?"close":"keep-alive";

        // next likely: resp header is "close"
        if(close && _StrUtil.equalIgnoreCase(header, "close"))
            return header;

        // unlikely general case. header may already contain "close/keep-alive" tokens
        StringBuilder sb = new StringBuilder();
        boolean set = false;
        for(String token: header.split(","))
        {
            token = token.trim();
            if(_StrUtil.equalIgnoreCase(token, "close"))
            {
                if(!close)  // in fact not possible
                    token = "keep-alive";
                set = true;
            }
            else if(_StrUtil.equalIgnoreCase(token, "keep-alive"))
            {
                if(close)
                    token = "close";
                set = true;
            }
            if(sb.length()>0) sb.append(", ");
            sb.append(token);
        }
        if(!set)
        {
            if(sb.length()>0) sb.append(", ");
            sb.append(close?"close":"keep-alive");
        }
        return sb.toString();
    }

    static boolean shouldGzip(HttpEntity entity, HttpServerConf conf)
    {
        if(entity==null)  // 204 or 304
            return false;

        Long bodyLen = entity.contentLength();
        if(bodyLen!=null && bodyLen.longValue()<conf.autoGzipMinContentLength)
            return false;
        // ok if body length is unknown

        if(entity.contentEncoding()!=null) // already encoded somehow?
            return false;


        HashSet<String> autoGzipContentTypes = conf.autoGzipContentTypeSet;
        assert autoGzipContentTypes!=null;
        ContentType contentType = entity.contentType();
        if(contentType==null)
            return false;
        if( !autoGzipContentTypes.contains(contentType.type()) &&
            !autoGzipContentTypes.contains(contentType.types()))
            return false;

        return true;
    }
    static void modGzip(int acceptGzip, HttpResponseImpl resp, HttpServerConf conf)
    {
        // for any request method and response status.

        HttpEntity entity = resp.entity;
        if(!shouldGzip(entity, conf))
            return;

        // add Vary: Accept-Encoding
        // the Vary header is added even if the response is not gzip-ed(because client doesn't accept gzip)
        //   Accept-Encoding is used for negotiation of representation regardless.
        _HttpUtil.addVaryHeader(resp.headers, Accept_Encoding);

        if(acceptGzip==2) // Accept-Encoding: gzip
            resp.entity = new GzipHttpEntity(entity, 1);  // on-the-fly gzip, use level 1, good enough.
    }

    // for request header TE or Accept-Encoding
    // codings:  1#( token [ ";" "q" "=" qvalue ] )
    //           (actually, more complicated than that for "transfer-extension", which we don't support)
    // example:  deflate, gzip;q=1.0, compress;q=0.5, *;q=0
    // return [+1] yes [0] no [-1] parse error
    static int acceptEncoding(String codings, String coding)
    {
        if(codings==null)
            return 0;

        final int N = codings.length();
        int i=0; // i<=N
        while(true)
        {
            // this element:  token [ ;q=qvalue ]
            i = _StrUtil.skipWhiteSpaces(codings, i);
            if(i==N)
                return -1;
            // match token and coding
            boolean match=false;
            final int J = coding.length();
            int j=0;  // j<=J
            for( ; i<N; i++)
            {
                char ch = codings.charAt(i);
                assert ch<=0xff;
                if(!_CharDef.check(ch, _CharDef.Http.tokenChars)) // token ends. most likely ch is , ; SP
                {
                    match = (j==J);
                    break;
                }

                if(j==J)
                    break;
                char ch2 = coding.charAt(j);
                if(!_StrUtil.sameCharIgnoreCase(ch, ch2))
                    break;
                j++;
            }
            if(i==N) // end of entire field
                return (j==J)? +1 : 0 ;
            int iComma = codings.indexOf(',', i);
            if(!match) // skip to next element
            {
                if(iComma==-1)  // no next element
                    return 0;
                i = iComma+1;
                continue;
            }

            // coding matched. we need to see if q=0. that's very rare.
            // usually no q at all. usually token is immediately followed by comma: "... gzip, ..."
            float q = qValue(codings, i, (iComma==-1) ? N : iComma ) ;
            return  (q>0.0f) ? +1 : (q==0.0f) ?  0 : -1;
        }
    }
    // range str[start,end) is in form [;q=v]. if empty(or all white), it's same as ;q=1.
    // normally return 0 or positive; if malformed return negative
    static float qValue(String str, int start, int end)
    {
        if(start==end) // very very common
            return 1.0f;

        int iEQ = str.indexOf('=', start);
        if(iEQ==-1 || iEQ>=end)  // no = in range. assume range is empty. (could be malformed in fact)
            return 1.0f;

        // there is a = sign in range. assume range is ;q=v (which we don't really check)
        // q value is rare in the header. the following code is usually not reached in practice.
        String v = str.substring(iEQ+1,end);  // trim will be done inside parseFloat()
        try
        {   return Float.parseFloat(v);   }  // if negative, v is malformed.
        catch(NumberFormatException e)
        {   return -1.0f;   }
    }

    static void modConditional(HttpResponseImpl resp, HeaderMap requestHeaders)
    {
        // only for GET/HEAD and status 200. other cases need to be handled by app

        HttpEntity entityL = resp.entity; // not null for 200

        HttpStatus statusL = checkConditions(requestHeaders, entityL); // 200, 304, 412
        if(statusL==c200_OK) // no mod to response
            return;

        resp.status = statusL; // 304, 412

        if(statusL==c304_Not_Modified)
        {
            // discard entity body, but keep the entity headers.
            // per spec, we SHOULD only copy 2 entity headers: ETag, Expires. no real problem to copy all
            copyEntityHeaders(entityL, resp.headers);
            resp.entity = null;
        }
        else // 412
        {
            // discard original entity
            resp.entity = new HttpHelper.SimpleTextEntity(statusL.toString());
        }
    }

    static void copyEntityHeaders(HttpEntity entity, HeaderMap headers)
    {
        // if a header already exist in `headers`, it may be overridden by value from entity.
        // note: must sanity check entity header values. may throw.

        ContentType contentType = entity.contentType();
        if(contentType!=null)
            headers.put(Content_Type, contentType.toString());  // content-type chars were checked

        String contentEncoding = entity.contentEncoding();
        if(contentEncoding!=null)
        {
            _HttpUtil.checkHeaderValue(Content_Encoding, contentEncoding);
            headers.put(Content_Encoding, contentEncoding);
        }

        // bodyLength is not an entity header

        String etag = entity.etag();
        if(etag!=null)
        {
            // we follow rfc2616, treat entity-tag as quoted-string.
            // therefore, server produced etag may need escape, and client supplied etag may need un-escape.
            // we also advised in getEtag() to exclude " and \ to avoid the problem (see http bis)
            _HttpUtil.validateEtag(etag);

            headers.put(ETag, _StrUtil.doQuote(etag));
        }

        Instant lastModified = entity.lastModified();
        if(lastModified!=null)
            headers.put(Last_Modified, _HttpDate.toHttpDate(lastModified));

        Instant expires = entity.expires();
        if(expires!=null)
        {
            // per rfc2616, it should not exceed 1 year from now.
            Instant oneYear = Instant.now().plusSeconds(365*24*3600); // will not overflow
            if(expires.isAfter(oneYear))
                expires = oneYear;
            // don't care if `Expires` is in the distant past, like year 0001.
            // worst case, client fails to parse or accept it.

            headers.put(Expires, _HttpDate.toHttpDate(expires));
        }
    }

    static HttpStatus checkConditions(HeaderMap requestHeaders, HttpEntity entity)
    {
        // we don't really expect If-Match or If-Unmodified-Since in a GET request; they don't make
        // much sense unless for a range request (but then If-Range is a better choice)
        // nevertheless, we'll support them according to the spec.
        // if any of the two fails, result is 412.

        String hv;

        hv = requestHeaders.get(If_Match);
        if(hv!=null && !matchEtag(hv, entity.etag()))
            return c412_Precondition_Failed;

        hv = requestHeaders.get(If_Unmodified_Since);
        if(hv!=null && modifiedSince(hv, entity.lastModified()))
            return c412_Precondition_Failed;

        // for If-None-Match and If-Modified-Since
        //            N   T   F
        //        N  200 200 304
        //        T  200 200 200
        //        F  304 200 304
        // if both conditions exist, and one is T, one is F, some inconsistency occurred.
        // the safe bet is to return 200 and current representation to client.
        // (we could return 412, but that's not useful to client)

        Boolean iIfNoneMatch = null;
        hv = requestHeaders.get(If_None_Match);
        if(hv!=null)
            iIfNoneMatch = !matchEtag(hv, entity.etag()) ? Boolean.TRUE : Boolean.FALSE ;

        if(iIfNoneMatch==Boolean.TRUE)
            return c200_OK;

        Boolean iIfModSince = null;
        hv = requestHeaders.get(If_Modified_Since);
        if(hv!=null)
            iIfModSince = modifiedSince(hv, entity.lastModified()) ? Boolean.TRUE : Boolean.FALSE ;

        if(iIfModSince==Boolean.TRUE)
            return c200_OK;


        if(iIfNoneMatch==null && iIfModSince==null)
            return c200_OK;

        return c304_Not_Modified;   // one F, another not T
    }

    // tags from If-Match/If-None-Match, tag from GET 200 entity (can be null)
    static boolean matchEtag(String tags, String tag)
    {
        if(tags.equals("*"))
            return true;  // even if tag==null
        if(tag==null)
            return false;

        // tags should be 1#entity-tag, and we treat entity-tag as quoted-string (rfc2616), with possible escaping.
        // if parsing fails, we should really return 400 to client. instead, we treat it simply as no match.
        int match = matchEtag2(tags, tag);
        return match == +1;
    }
    // return [+1] match  [0] no match. [-1] parsing fails, tags is malformed.
    static int matchEtag2(String tags, String tag)
    {
        final int N = tags.length();
        int i = 0;  // i<=N
        while(true)
        {
            // this element: [W/]"xxx"
            i = _StrUtil.skipWhiteSpaces(tags, i);
            if(i==N)
                return -1;
            boolean esc=false;
            if(tags.startsWith("W/\"", i)) // weak tag; out tag is always strong, won't match. to skip to next element
            {
                i+=3;
            }
            else if(tags.charAt(i)!=DQUOTE)
            {
                return -1;
            }
            else // DQUOTE. try match
            {
                i+=1;
                final int J = tag.length();
                int j=0; // j<=J
                for( ; i<N; i++)
                {
                    char ch = tags.charAt(i);
                    if(esc)
                    {
                        esc=false;
                        // to match ch
                    }
                    else if(ch==BACKSLASH)
                    {
                        esc=true;
                        continue;
                    }
                    else if(ch==DQUOTE) // end of this element
                    {
                        if(j==J)  // perfect match
                            return +1;  // actually the rest can still be malformed, but we look no further
                        else
                            break;
                    }
                    // else to match ch

                    if(j==J)
                        break;
                    char ch2 = tag.charAt(j);
                    if(ch!=ch2) // case sensitive
                        break;

                    j++;
                }
            }
            // this element does not match tag. skip to next element
            // seek the closing quote
            for(;i<N;i++)
            {
                char ch = tags.charAt(i);
                if(esc)
                    esc=false;
                else if(ch==BACKSLASH)
                    esc=true;
                else if(ch==DQUOTE)
                    break;
            }
            if(i==N) // no closing quote
                return -1;

            i+=1;
            i = _StrUtil.skipWhiteSpaces(tags, i);
            if(i==N)  // end of entire field, well-formed, no match
                return 0;
            if(tags.charAt(i)!=',')
                return -1;

            i+=1;
            // start of next element
        } // while(true)
    }

    // we allow false positive, which is not really harmful (for both cases, If-Mod/Unmod-Since)
    static boolean modifiedSince(String reqDate, Instant entityDate)
    {
        if(entityDate==null) // unsure, assume modified
            return true;
        // exact date match
        return !_HttpDate.match(entityDate, reqDate);  // only works if reqDate is rfc1123-date
    }



    static void modRange(HttpResponseImpl resp, HeaderMap requestHeaders)
    {
        // only for GET/HEAD and status 200. other cases need to be handled by app

        // see BrowserRangeTest

        // per spec, if entity has no strong validator, client can't combine partial results,
        // therefore it's logical that server does not support range request for the entity.
        //
        //        if(entity.etag()==null)
        //            return; // no range support without a strong validator.
        //
        // however, some clients (e.g. older firefox) don't care about that. so we don't care either.
        // we'll do range even without a validator, it's up to clients to violate spec.

        // if app sets Accept-Range header, it could be
        //     "none"  : app does not want to support range requests for the entity
        //     "bytes" : we assume app is going to handle range requests by itself, so we bail here
        //     ??????  : some custom range unit, which we don't understand. app will handle it.
        if(resp.headers.containsKey(Accept_Ranges))
            return;

        // if body length is unknown, we can't support range, because Content-Range in 206 response
        // requires a last-byte-pos which is difficult for us to choose a value.
        // oddly, (an older) firefox would send a range request to a resource with unknown length (for resumed download)
        Long bodyLength = resp.entity.contentLength();
        if(bodyLength==null)
            return;
        // if it's 0, modRange2() can handle it.

        // this entity can be ranged by us.

        // advertise [Accept-Ranges: bytes] for this entity.
        //     even if bodyLength is very small. that's a bit odd but ok.
        //     even in 206 responses. that's redundant but ok.
        resp.headers.put(Accept_Ranges, "bytes");

        modRange2(bodyLength.longValue(), requestHeaders, resp); // 200 => 200/206
    }
    static void modRange2(long bodyLength, HeaderMap requestHeaders, HttpResponseImpl resp)
    {
        // being lazy, we won't produce 416. if there's any reason we can't produce 206, we'll leave it as 200.
        // this is ok since range is optional - a 200 response is always allowed regardless of range headers.

        String hRange = requestHeaders.get(Range);
        if(hRange==null)   // most likely. not a range request.
            return;

        // expected format: "bytes=500-" or "bytes=500-999". should be the most common one.
        // ignore other cases - ok since range is optional.
        if(!hRange.startsWith("bytes="))
            return;
        int iDash = hRange.indexOf('-');
        if(iDash==-1)
            return;
        long rangeMin, rangeMax;
        try
        {
            String sMin = hRange.substring(6, iDash); // no '-' char in it
            rangeMin = Long.parseLong(sMin);          // won't be negative

            String sMax = hRange.substring(iDash+1);
            rangeMax = sMax.isEmpty()? Long.MAX_VALUE : Long.parseLong(sMax);
        }
        catch (NumberFormatException e)
        {
            return;  // whatever dude
        }

        if(rangeMax<rangeMin)  // requires at least 1 byte (when max=min)
            return;

        if(rangeMin >= bodyLength)  // if bodyLength==0, we'll exit here
            return;

        if( rangeMax >= bodyLength)
            rangeMax = bodyLength-1;

        // 0 <= min <= max < bodyLength

        HttpEntity entityL = resp.entity;

        String hIfRange = requestHeaders.get(If_Range);
        if(hIfRange!=null)
        {
            // it must not be a weak etag (W/"..."). if it is, we treat it as date (and fail to match)

            if(hIfRange.charAt(0)==DQUOTE) // strong etag
            {
                int len = hIfRange.length();
                if(hIfRange.charAt(len-1)!=DQUOTE) // malformed
                    return;

                String etag = entityL.etag();
                if(etag==null)
                    return;
                if(!hIfRange.substring(1, len-1).equals(etag))
                    return;
            }
            else // date
            {
                Instant lastModified = entityL.lastModified();
                if(lastModified==null)
                    return;
                if(!_HttpDate.match(lastModified, hIfRange))
                    return;  // maybe date is not in rfc1123-date format, that's fine
            }

            // If-Range matched etag or lastModified
        }

        // yes, really do range

        resp.status = c206_Partial_Content;

        resp.headers.put(Content_Range, "bytes " + rangeMin + '-' + rangeMax + '/' + bodyLength); //"bytes 500-999/1234"

        resp.entity = new RangedEntity(entityL, rangeMin, rangeMax+1); // note the convention change for max
    }
    static class RangedEntity implements HttpEntityWrapper
    {
        HttpEntity origin;
        long min, max;
        public RangedEntity(HttpEntity origin, long min, long max)
        {
            this.origin = origin;
            this.min = min;
            this.max = max;
        }
        @Override public HttpEntity getOriginEntity()
        {
            return origin;
        }
        @Override public Long contentLength()
        {
            return max-min;
        }
        @Override
        public ByteSource body()
        {
            ByteSource originBody = origin.body();
            // next line doesn't throw, or we need to close originBody
            return new RangedByteSource(originBody, min, max);
            // note: RangedByteSource doesn't care if origin body premature EOF.
            // that's ok. if premature EOF, ImplConnResp will find out.
        }
    }


    static void modCacheControl(HttpEntity entity, HeaderMap headers)
    {
        // GET/HEAD only. not sure about response status. maybe useful for non-200 responses too.
        // for unsafe requests, caches probably shouldn't cache the responses anyway.
        // if app knows better, it needs to handle Cache-Control by itself.
        if(headers.containsKey(Cache_Control))
            return; // leave it as is.

        // always private to be safe; we can't know if a resource can be cached publicly.
        // if app knows better, app needs to set the proper Cache-Control before us.

        boolean hasExpires = (entity!=null && entity.expires()!=null)
                || headers.containsKey(Expires);  // app may set Expires in general headers

        if(hasExpires)
            headers.put(Cache_Control, "private");
        else // no Expires. "no-cache" to disable stupid "heuristic expiration" by caches
            headers.put(Cache_Control, "private, no-cache");
    }

    static final char DQUOTE  = '\"';
    static final char BACKSLASH  = '\\';

}
